"""FlowMDM SMPLX Motion Animation Utility (PyVista / Qt)

Interactive visualization of generated FlowMDM SMPLX mesh sequences.
Provides smooth real-time playback of full-body SMPLX meshes with
efficient in-place vertex updates (no per-frame allocations).

Key Features:
* Interactive 3D SMPLX mesh animation (play/pause, frame stepping, reset, quit)
* Auto-discovery of `smplx_pose.npy` when a directory is provided
* Supports SMPLX pose arrays generated by generate-ex.py --export-smplx
* Efficient mesh vertex updates via in-place modification for performance
* Full 3D human body visualization with realistic mesh topology

Usage Examples:
    # Directory containing smplx_pose.npy
    python visualization/show-animation-smplx.py results/babel/FlowMDM/001300000_s10_simple_walk_instructions --smplx-model-path ../../data

    # Direct file path
    python visualization/show-animation-smplx.py results/babel/FlowMDM/001300000_s10_simple_walk_instructions/smplx_pose.npy --smplx-model-path ../../data

    # Autoplay and custom FPS
    python visualization/show-animation-smplx.py <RESULT_DIR> --smplx-model-path ../../data --autoplay --fps 24

Arguments:
    results_path       Path to a directory containing `smplx_pose.npy` or the file itself
    --smplx-model-path Path to PARENT directory containing 'smplx' folder with model files (REQUIRED)
    --autoplay         Start playback immediately (default: start paused)
    --fps INT          Target playback FPS (default 30; adjust for slow/fast review)
    --gender STR       SMPLX model gender: neutral, male, female (default: neutral)

Controls (inside the window):
    Space           Play / Pause
    Left / Right    Step one frame backward / forward (pauses playback)
    r               Reset to frame 0
    q               Quit / close window

Data Format:
    SMPLX pose array shape: (seq_len, 165) or list of such arrays
    165 parameters: global_orient(3) + body_pose(63) + hand_poses(90) + jaw_pose(3) + eye_poses(6)

Performance Notes:
    * Single PolyData for mesh; vertices updated in place each frame
    * SMPLX forward pass computed once per frame for vertex positions
    * Timer callback interval derived from requested FPS (ms = 1000 / fps)

Recommended Environment:
    Run under the modern pixi "latest" env for newer PyVista & Qt stack:
        pixi run -e latest python visualization/show-animation-smplx.py <RESULT_DIR> --smplx-model-path ../../data
"""

import pathlib
import argparse
import json
import os.path as osp
from typing import Optional, Dict, List, Any

import numpy as np
import pyvista as pv
import pyvistaqt as pvqt
import vtk
import torch

# Motion data loaded later from CLI argument (populated in __main__)
smplx_pose_data: Optional[np.ndarray] = None
smplx_transl_data: Optional[np.ndarray] = None
result_info: Optional[Dict] = None
smplx_result_file: Optional[pathlib.Path] = None
input_path: Optional[pathlib.Path] = None


class FlowMDMSMPLXAnimator:
    """Interactive animator for FlowMDM SMPLX mesh data with in-place geometry updates.
    
    This class provides real-time 3D visualization of SMPLX mesh sequences
    with efficient geometry updates and interactive controls. The animation system
    uses in-place vertex updates to achieve smooth 30 FPS playback without memory
    allocation during the animation loop.
    
    Parameters
    ----------
    smplx_pose_data : np.ndarray or list
        SMPLX pose sequence data with shape (seq_len, 165) where:
        - seq_len: number of frames in the sequence
        - 165: SMPLX pose parameters (global_orient + body_pose + hand_poses + jaw + eyes)
    smplx_model_path : str
        Path to parent directory containing 'smplx' folder with model files
    gender : str
        SMPLX model gender: 'neutral', 'male', or 'female'
    
    Attributes
    ----------
    smplx_pose_data : np.ndarray
        The input SMPLX pose sequence data
    smplx_model : smplx.SMPLX
        The SMPLX model instance for generating vertices
    current_frame : int
        Current animation frame index
    total_frames : int
        Total number of frames in the sequence
    is_playing : bool
        Animation playback state
    fps : float
        Target frames per second (30.0 for Babel dataset)
    plotter : pvqt.BackgroundPlotter
        PyVista Qt plotter for 3D rendering
    mesh_poly : pv.PolyData
        SMPLX mesh polydata with updateable vertex positions
    mesh_actor : pv.Actor
        SMPLX mesh actor in the scene
    vtk_text_actor : vtk.vtkTextActor
        Status text actor for efficient text updates
    """
    
    def __init__(self, smplx_pose_data, smplx_model_path: str, gender: str = 'neutral', smplx_transl_data: Optional[np.ndarray] = None, to_y_up: bool = True) -> None:
        """Initialize the FlowMDM SMPLX animator with pose data and model.
        
        Sets up the 3D scene, SMPLX model, mesh geometry, and animation controls.
        Creates all necessary visualization components and prepares for real-time
        animation playback.
        
        Parameters
        ----------
        smplx_pose_data : np.ndarray or list
            SMPLX pose sequence data
        smplx_model_path : str
            Path to parent directory containing 'smplx' folder
        gender : str
            SMPLX model gender
        smplx_transl_data : Optional[np.ndarray]
            Optional translation data for root locomotion
            
        Notes
        -----
        This method performs several initialization steps:
        1. Validates and loads SMPLX model
        2. Processes pose data format and validates dimensions
        3. Creates PyVista Qt plotter window
        4. Sets up 3D scene with ground plane and lighting
        5. Generates initial mesh from first frame
        6. Sets up efficient VTK text actor for status display
        7. Registers keyboard controls and timer callbacks
        """
        # Process and validate pose data
        self.smplx_pose_data = self._process_pose_data(smplx_pose_data)
        
        # Process translation data if provided
        self.smplx_transl_data = None
        if smplx_transl_data is not None:
            self.smplx_transl_data = self._process_translation_data(smplx_transl_data)
            
        # Validate data dimensions and detect static sequences
        self._validate_data()
        
        self.current_frame = 0
        self.total_frames = self.smplx_pose_data.shape[0]
        self.is_playing = False
        self.fps = 30.0

        # Initialize SMPLX model
        self._init_smplx_model(smplx_model_path, gender)
        self.apply_y_up = to_y_up
        if self.apply_y_up:
            print('[info] Converting SMPLX Z-up output to Y-up (rotate -90 deg about X) to match FlowMDM skeleton viewer')
        else:
            print('[info] Keeping original SMPLX Z-up coordinates')

        # Plotter (Qt background)
        self.plotter = pvqt.BackgroundPlotter(  # type: ignore[attr-defined]
            title="FlowMDM SMPLX Mesh Animation - Full Body",
            window_size=(1024, 768)
        )
        self._setup_scene()
        self._setup_controls()

        # Generate initial mesh
        self.mesh_poly = self._build_smplx_mesh_polydata(0)
        self.mesh_actor = self.plotter.add_mesh(  # type: ignore[attr-defined]
            self.mesh_poly,
            color=[0.8, 0.7, 0.6],  # Skin-like color
            show_edges=False,
            smooth_shading=True,
            opacity=0.9
        )

        # Status text actor - Create VTK text actor directly for guaranteed efficient updates
        self.vtk_text_actor = vtk.vtkTextActor()
        self.vtk_text_actor.SetInput("Frame 0")
        self.vtk_text_actor.GetPositionCoordinate().SetCoordinateSystemToNormalizedViewport()
        self.vtk_text_actor.GetPositionCoordinate().SetValue(0.02, 0.02)  # lower_left position
        
        # Set text properties - larger font for visibility
        text_prop = self.vtk_text_actor.GetTextProperty()
        text_prop.SetFontSize(16)
        text_prop.SetColor(0, 0, 0)
        text_prop.SetJustificationToLeft()
        text_prop.SetVerticalJustificationToBottom()
        
        # Add to plotter as VTK actor
        self.plotter.add_actor(self.vtk_text_actor, name='status_text')  # type: ignore[attr-defined]

        # Initial frame
        self.render_frame(0)

        # Register timer callback
        self.plotter.add_callback(self._on_timer, interval=int(1000 / self.fps))  # type: ignore[attr-defined]

    def _init_smplx_model(self, model_path: str, gender: str) -> None:
        """Initialize SMPLX model for mesh generation.
        
        Parameters
        ----------
        model_path : str
            Path to parent directory containing 'smplx' folder
        gender : str
            Model gender: 'neutral', 'male', or 'female'
        """
        try:
            import smplx
            
            # Validate model path
            smplx_subdir = osp.join(model_path, 'smplx')
            if not osp.exists(smplx_subdir):
                raise ValueError(
                    f"[error] SMPLX model directory not found at {smplx_subdir}\n"
                    f"        You provided: {model_path}\n"
                    f"        This should be the PARENT directory containing 'smplx' folder.\n"
                    f"        Example: use '../../data' instead of '../../data/smplx'"
                )
            
            print(f"[info] Loading SMPLX model from {model_path} (gender: {gender})")
            self.smplx_model = smplx.create(
                model_path=model_path,
                model_type='smplx',
                gender=gender,
                batch_size=1,  # Process one frame at a time
                use_pca=False,
                flat_hand_mean=False
            )
            print("[info] SMPLX model loaded successfully")
            
        except ImportError:
            raise ImportError(
                "SMPLX package is required for mesh visualization. Install with: pip install smplx"
            )
        except Exception as e:
            raise RuntimeError(f"Failed to load SMPLX model: {e}") from None
            
    def _process_pose_data(self, smplx_pose_data) -> np.ndarray:
        """Process and validate pose data format.
        
        Parameters
        ----------
        smplx_pose_data : various
            Input pose data in various formats
            
        Returns
        -------
        np.ndarray
            Processed pose data with shape (seq_len, 165)
        """
        # Handle pose data format (could be list of arrays or numpy object array)
        if isinstance(smplx_pose_data, np.ndarray) and smplx_pose_data.dtype == object:
            # Handle object array - try to convert to float first
            try:
                # Try to convert the entire object array to float
                pose_data: np.ndarray = smplx_pose_data.astype(np.float32)
            except (ValueError, TypeError):
                # If direct conversion fails, try to extract data differently
                if smplx_pose_data.shape == ():
                    # Single object containing list/array
                    data: Any = smplx_pose_data.item()
                    if isinstance(data, list):
                        pose_data = np.array(data[0]) if data else np.zeros((1, 165))
                    else:
                        pose_data = np.array(data)
                else:
                    # Multi-dimensional object array - try to reconstruct
                    try:
                        # Try to convert each sequence individually and stack
                        sequences: List[np.ndarray] = []
                        if smplx_pose_data.ndim >= 2:
                            for i in range(smplx_pose_data.shape[0]):
                                seq = smplx_pose_data[i]
                                if hasattr(seq, 'astype'):
                                    sequences.append(seq.astype(np.float32))
                                else:
                                    sequences.append(np.array(seq, dtype=np.float32))
                            pose_data = sequences[0] if sequences else np.zeros((1, 165))
                        else:
                            # Flat object array
                            pose_data = np.array(list(smplx_pose_data.flat), dtype=np.float32)
                    except Exception as e2:
                        raise ValueError(f"Could not convert object array to numeric data: {e2}") from None
        elif isinstance(smplx_pose_data, list):
            # Convert list to single array - take first sequence
            pose_data = np.array(smplx_pose_data[0]) if smplx_pose_data else np.zeros((1, 165))
        else:
            # Regular numpy array
            pose_data = smplx_pose_data
            
        # Ensure proper numeric dtype
        if hasattr(pose_data, 'dtype') and pose_data.dtype == object:
            raise ValueError("Failed to convert pose data from object dtype to numeric")
                        
        # Ensure 2D array (frames, pose_dim)
        if pose_data.ndim == 1:
            pose_data = pose_data.reshape(1, -1)
        elif pose_data.ndim == 3:
            # Shape might be (batch, frames, pose_dim) - take first batch
            pose_data = pose_data[0]
        
        return pose_data
        
    def _process_translation_data(self, smplx_transl_data) -> Optional[np.ndarray]:
        """Process translation data format.
        
        Parameters
        ----------
        smplx_transl_data : various
            Input translation data
            
        Returns
        -------
        Optional[np.ndarray]
            Processed translation data with shape (seq_len, 3) or None
        """
        if smplx_transl_data is None:
            return None
            
        # Convert to numpy array if needed
        if isinstance(smplx_transl_data, list):
            transl_data: np.ndarray = np.array(smplx_transl_data, dtype=np.float32)
        else:
            transl_data = smplx_transl_data.astype(np.float32)
            
        # Ensure proper shape
        if transl_data.ndim == 1:
            transl_data = transl_data.reshape(1, -1)
        elif transl_data.ndim == 3:
            # Take first batch if batched
            transl_data = transl_data[0]
            
        return transl_data
        
    def _validate_data(self) -> None:
        """Validate pose data dimensions and detect issues."""
        # Validate pose dimensions
        if self.smplx_pose_data.shape[1] != 165:
            raise ValueError(
                f"Expected pose dimension 165, got {self.smplx_pose_data.shape[1]}. "
                f"SMPLX pose should have 165 parameters: global_orient(3) + body_pose(63) + "
                f"hand_poses(90) + jaw_pose(3) + eye_poses(6)"
            )
            
        # Validate sequence length
        if self.smplx_pose_data.shape[0] < 1:
            raise ValueError("Pose data must contain at least 1 frame")
            
        # Warn if only one frame
        if self.smplx_pose_data.shape[0] == 1:
            print("[warn] Pose data contains only 1 frame - animation will be static")
            
        # Validate translation data if provided
        if self.smplx_transl_data is not None:
            if self.smplx_transl_data.shape[0] != self.smplx_pose_data.shape[0]:
                raise ValueError(
                    f"Translation data length ({self.smplx_transl_data.shape[0]}) "
                    f"must match pose data length ({self.smplx_pose_data.shape[0]})"
                )
            if self.smplx_transl_data.shape[1] != 3:
                raise ValueError(
                    f"Translation data must have 3 dimensions (x,y,z), got {self.smplx_transl_data.shape[1]}"
                )
                
        # Detect static sequences (warn if all frames identical)
        if self.smplx_pose_data.shape[0] > 1:
            if np.allclose(self.smplx_pose_data[0], self.smplx_pose_data[-1], atol=1e-6):
                # Check if all frames are identical
                all_identical = True
                for i in range(1, min(10, self.smplx_pose_data.shape[0])):
                    if not np.allclose(self.smplx_pose_data[0], self.smplx_pose_data[i], atol=1e-6):
                        all_identical = False
                        break
                        
                if all_identical:
                    print("[warn] Pose sequence appears to be static (all frames identical). "
                          "Check export pipeline if motion was expected.")
                    
        # Check for NaN or Inf values
        if np.any(~np.isfinite(self.smplx_pose_data)):
            nan_count: int = int(np.sum(~np.isfinite(self.smplx_pose_data)))
            raise ValueError(f"Pose data contains {nan_count} NaN or Inf values")
            
        if self.smplx_transl_data is not None and np.any(~np.isfinite(self.smplx_transl_data)):
            transl_nan_count: int = int(np.sum(~np.isfinite(self.smplx_transl_data)))
            raise ValueError(f"Translation data contains {transl_nan_count} NaN or Inf values")
            
        print(f"[info] Validated pose data: {self.smplx_pose_data.shape[0]} frames, 165 parameters")
        if self.smplx_transl_data is not None:
            print(f"[info] Translation data available: {self.smplx_transl_data.shape[0]} frames")
        else:
            print("[info] No translation data - character will remain at origin")
            
    def _parse_pose_frame(self, frame_index: int) -> Dict[str, torch.Tensor]:
        """Parse SMPLX pose parameters for a single frame.
        
        Parameters
        ----------
        frame_index : int
            Frame number to extract pose from (0-based index)
            
        Returns
        -------
        Dict[str, torch.Tensor]
            Dictionary containing parsed SMPLX parameters as tensors
        """
        # Get pose for this frame
        pose = self.smplx_pose_data[frame_index]  # Shape: (165,)
        
        # Parse pose components (following SMPLX format)
        global_orient = pose[:3]  # (3,)
        body_pose = pose[3:66]    # (63,) - 21 joints * 3
        left_hand_pose = pose[66:111]   # (45,) - 15 joints * 3
        right_hand_pose = pose[111:156] # (45,) - 15 joints * 3
        jaw_pose = pose[156:159]        # (3,)
        leye_pose = pose[159:162]       # (3,)
        reye_pose = pose[162:165]       # (3,)
        
        # Convert to tensors
        parsed = {
            'global_orient': torch.from_numpy(global_orient).float().unsqueeze(0),  # (1, 3)
            'body_pose': torch.from_numpy(body_pose).float().unsqueeze(0).reshape(1, 21, 3),  # (1, 21, 3)
            'left_hand_pose': torch.from_numpy(left_hand_pose).float().unsqueeze(0).reshape(1, 15, 3),  # (1, 15, 3)
            'right_hand_pose': torch.from_numpy(right_hand_pose).float().unsqueeze(0).reshape(1, 15, 3),  # (1, 15, 3)
            'jaw_pose': torch.from_numpy(jaw_pose).float().unsqueeze(0),  # (1, 3)
            'leye_pose': torch.from_numpy(leye_pose).float().unsqueeze(0),  # (1, 3)
            'reye_pose': torch.from_numpy(reye_pose).float().unsqueeze(0),  # (1, 3)
            'betas': torch.zeros(1, 10),  # Default shape
            'expression': torch.zeros(1, 10)  # Default expression
        }
        
        # Add translation if available
        if self.smplx_transl_data is not None:
            transl = self.smplx_transl_data[frame_index]  # (3,)
            parsed['transl'] = torch.from_numpy(transl).float().unsqueeze(0)  # (1, 3)
            
        return parsed

    def _setup_scene(self) -> None:
        """Set up the 3D scene with ground plane, lighting, and camera.
        
        Creates the basic 3D environment for SMPLX mesh visualization including:
        - Semi-transparent ground plane for spatial reference
        - Optimal lighting for mesh visualization
        - Light background for better contrast
        - Camera position optimized for full-body viewing
        """
        # Ground plane
        plane = pv.Plane(center=[0, 0, 0], direction=[0, 1, 0], i_size=4, j_size=4, i_resolution=20, j_resolution=20)
        self.plotter.add_mesh(plane, color=[0.6, 0.6, 0.6], opacity=0.2, show_edges=True, line_width=0.5)  # type: ignore[attr-defined]
        
        # Lighting for mesh
        self.plotter.add_axes()  # type: ignore[attr-defined]
        self.plotter.set_background([0.95, 0.95, 0.95])  # type: ignore[attr-defined]
        self.plotter.camera_position = ([3, 1.5, 3], [0, 1, 0], [0, 1, 0])  # type: ignore[attr-defined]
        
        # Add better lighting for mesh visualization
        light = pv.Light(position=[2, 3, 2], focal_point=[0, 1, 0], color=[1.0, 1.0, 1.0])
        self.plotter.add_light(light)  # type: ignore[attr-defined]

    def _setup_controls(self) -> None:
        """Register keyboard event handlers for animation control."""
        for key in (' ', 'space'):
            self.plotter.add_key_event(key, self.toggle_animation)  # type: ignore[attr-defined]
        self.plotter.add_key_event('Left', lambda: self.step_frame(-1))  # type: ignore[attr-defined]
        self.plotter.add_key_event('Right', lambda: self.step_frame(1))  # type: ignore[attr-defined]
        self.plotter.add_key_event('r', self.reset_animation)  # type: ignore[attr-defined]
        self.plotter.add_key_event('q', self.quit_animation)  # type: ignore[attr-defined]

    def _build_smplx_mesh_polydata(self, frame_index: int) -> pv.PolyData:
        """Build PyVista PolyData for the SMPLX mesh at a specific frame.
        
        Creates a PolyData object containing the SMPLX mesh vertices and faces
        for the specified frame. The resulting geometry can be efficiently 
        updated by modifying vertex positions without recreating the topology.
        
        Parameters
        ----------
        frame_index : int
            Frame number to extract pose from (0-based index)
            
        Returns
        -------
        pv.PolyData
            PolyData object with:
            - points: SMPLX mesh vertices (shape: Nx3)
            - faces: mesh triangulation
        """
        # Parse pose parameters for this frame
        pose_params = self._parse_pose_frame(frame_index)
        
        # SMPLX forward pass with error handling
        try:
            with torch.no_grad():
                output = self.smplx_model(**pose_params)
        except Exception as e:
            print(f"[error] SMPLX forward pass failed at frame {frame_index}: {e}")
            # Use default T-pose as fallback
            with torch.no_grad():
                output = self.smplx_model(
                    global_orient=torch.zeros(1, 3),
                    body_pose=torch.zeros(1, 21, 3),
                    left_hand_pose=torch.zeros(1, 15, 3),
                    right_hand_pose=torch.zeros(1, 15, 3),
                    jaw_pose=torch.zeros(1, 3),
                    leye_pose=torch.zeros(1, 3),
                    reye_pose=torch.zeros(1, 3),
                    betas=torch.zeros(1, 10),
                    expression=torch.zeros(1, 10)
                )
        
        vertices = output.vertices[0].cpu().numpy()  # (N, 3)
        if self.apply_y_up:
            # Rotate -90 deg about X: (x, y, z)_Zup -> (x, z, -y)_Yup (vertices only)
            x = vertices[:, 0].copy()
            y = vertices[:, 1].copy()
            z = vertices[:, 2].copy()
            vertices[:, 0] = x
            vertices[:, 1] = z
            vertices[:, 2] = -y
        faces = self.smplx_model.faces.astype(np.int32)  # (F, 3)
        
        # Create PyVista mesh
        # PyVista faces format: [3, v0, v1, v2, 3, v3, v4, v5, ...]
        pv_faces = np.hstack([[3] + face.tolist() for face in faces])
        
        poly = pv.PolyData()
        poly.points = vertices
        poly.faces = pv_faces
        
        return poly

    def render_frame(self, frame_index: int) -> None:
        """Render a specific animation frame with efficient geometry updates.
        
        Updates the 3D visualization to display the SMPLX mesh at the
        specified frame. Uses in-place geometry updates for maximum performance.
        
        Parameters
        ----------
        frame_index : int
            Target frame to render (0-based index)
        """
        if not (0 <= frame_index < self.total_frames):
            return
        self.current_frame = frame_index
        
        # Parse pose parameters for this frame
        pose_params = self._parse_pose_frame(frame_index)
        
        # SMPLX forward pass with error handling
        try:
            with torch.no_grad():
                output = self.smplx_model(**pose_params)
        except Exception as e:
            print(f"[error] SMPLX forward pass failed at frame {frame_index}: {e}")
            # Pause animation on error to avoid spamming
            self.is_playing = False
            return
        
        vertices = output.vertices[0].cpu().numpy()
        if self.apply_y_up:
            x = vertices[:, 0].copy()
            y = vertices[:, 1].copy()
            z = vertices[:, 2].copy()
            vertices[:, 0] = x
            vertices[:, 1] = z
            vertices[:, 2] = -y
        
        # Update mesh points in place
        pts = self.mesh_poly.points
        np.copyto(pts, vertices)
        self.mesh_poly.points = pts
        
        # Update status text
        status = f"F {frame_index}/{self.total_frames-1} | {'Play' if self.is_playing else 'Pause'} | SMPLX Mesh"
        self.vtk_text_actor.SetInput(status)
        self.plotter.render()  # type: ignore[attr-defined]

    def _on_timer(self) -> None:
        """Timer callback for automatic animation playback."""
        if self.is_playing:
            self.render_frame((self.current_frame + 1) % self.total_frames)

    def toggle_animation(self) -> None:
        """Toggle between play and pause states."""
        self.is_playing = not self.is_playing
        print("Playing" if self.is_playing else "Paused")

    def step_frame(self, direction: int) -> None:
        """Step animation by one frame in the specified direction."""
        self.is_playing = False
        self.render_frame((self.current_frame + direction) % self.total_frames)

    def reset_animation(self) -> None:
        """Reset animation to the first frame."""
        self.is_playing = False
        self.render_frame(0)
        print("Animation reset")

    def quit_animation(self) -> None:
        """Stop animation and close the visualization window."""
        self.is_playing = False
        self.plotter.close()  # type: ignore[attr-defined]

    def show(self) -> None:
        """Start the interactive animation display."""
        print("\nSMPLX Animation Controls:")
        print("  Spacebar: Play/Pause")
        print("  Left/Right arrows: Step frame")
        print("  r: Reset")
        print("  q: Quit")
        print("\nStarting interactive SMPLX animation...")
        self.plotter.show()  # type: ignore[attr-defined]


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Interactive FlowMDM SMPLX mesh animation (PyVista)")
    parser.add_argument("results_path", help="Path to results directory or smplx_pose.npy file")
    parser.add_argument("--smplx-model-path", required=True, help="Path to PARENT directory containing 'smplx' folder with model files")
    parser.add_argument("--autoplay", action="store_true", help="Start playing immediately instead of paused")
    parser.add_argument("--fps", type=int, default=30, help="Target playback FPS (default 30)")
    parser.add_argument("--gender", choices=['neutral', 'male', 'female'], default='neutral', help="SMPLX model gender")
    parser.add_argument("--keep-z-up", action='store_true', help="Do not rotate SMPLX output; keep original Z-up coordinates")
    parser.add_argument("--transl-file", help="Path to translation file (smplx_transl.npy) for root locomotion. If not provided, will try to auto-discover smplx_transl.npy in same directory as pose data")
    args = parser.parse_args()

    input_path = pathlib.Path(args.results_path)
    if not input_path.exists():
        raise FileNotFoundError(f"Provided path does not exist: {input_path}")

    # Look for SMPLX pose data
    if input_path.is_dir():
        candidate = input_path / "smplx_pose.npy"
        if not candidate.exists():
            found = list(input_path.glob("**/smplx_pose.npy"))
            if not found:
                raise FileNotFoundError(f"Could not find smplx_pose.npy inside directory: {input_path}")
            smplx_result_file = found[0]
        else:
            smplx_result_file = candidate
    else:
        smplx_result_file = input_path
        if smplx_result_file.name != "smplx_pose.npy":
            raise ValueError("Results file must be named smplx_pose.npy when providing a file path")

    # Load SMPLX pose data
    smplx_pose_data = np.load(smplx_result_file, allow_pickle=True)
    
    # Load translation data if available
    smplx_transl_data = None
    if args.transl_file:
        # Explicit translation file provided
        transl_path = pathlib.Path(args.transl_file)
        if transl_path.exists():
            print(f"[info] Loading translation data from: {transl_path}")
            smplx_transl_data = np.load(transl_path, allow_pickle=True)
        else:
            print(f"[warn] Translation file not found: {transl_path}")
    else:
        # Try to auto-discover translation file in same directory
        transl_candidate = smplx_result_file.parent / "smplx_transl.npy"
        if transl_candidate.exists():
            print(f"[info] Auto-discovered translation data: {transl_candidate}")
            smplx_transl_data = np.load(transl_candidate, allow_pickle=True)
    
    # Try to load layout info if available
    layout_file = smplx_result_file.parent / "smplx_layout.json"
    result_info = {}
    if layout_file.exists():
        with open(layout_file) as f:
            result_info = json.load(f)

    print(f"Loaded SMPLX pose data: {type(smplx_pose_data)} - {getattr(smplx_pose_data, 'shape', 'list/object')}")
    if result_info:
        print(f"Layout: {result_info.get('layout', 'N/A')}")
        print(f"Metadata: {result_info.get('meta', 'N/A')}")
    
    animator = FlowMDMSMPLXAnimator(smplx_pose_data, args.smplx_model_path, args.gender, smplx_transl_data, to_y_up=not args.keep_z_up)
    animator.fps = float(args.fps)
    
    if args.autoplay:
        animator.toggle_animation()

    animator.show()

    # Handle Qt event loop
    app = getattr(animator.plotter, 'app', None)
    if app is not None:
        try:
            closing = getattr(app, 'closingDown', lambda: False)()
            if not closing:
                app.exec_()
        except Exception as e:
            print(f"[warn] Qt event loop failed: {e}")